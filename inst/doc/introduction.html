<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Pipeline Overview</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Pipeline Overview</h1>

<p>The VariTAS pipeline is an R package for processing amplicon-based targeted sequencing. It supports alignment, somatic variant calling (with and without matched normal), and variant annotation, and the pipeline can start from any stage. </p>

<p>Both Illumina sequencing (typically MiniSeq) and Ion Torrent systems are supported by the pipeline, but they require different configurations. For Illumina runs, the FASTQ files are used to start the pipeline at the alignment stage. For Ion Torrent sequencing, the aligned BAM files from the machine are used as input. </p>

<p>The pipeline is designed to be fully automated. Once the pipeline is launched, cluster jobs will be submitted for all tasks. In the case that some jobs depend on others, these job dependencies will be included in the script and handled by the cluster. </p>

<p>Each stage of the pipeline is associated with a file specification data frame. This data frame contains paths to the files to be processed at that stage, and information on any job dependencies. In turn, each pipeline stage will return a data frame that can be used for the next stage in the pipeline. </p>

<p>File paths, run parameters, HPC settings, and other options are controlled by a config file. See the <a href="#settings">Updating Settings</a> section below for more details.</p>

<p>To start using the pipeline quickly, see the <a href="#examples">Examples</a> section.</p>

<h2>Third-Party Software</h2>

<p>There are several essential programs that the VariTAS pipeline requires. The table below provides essential information about each of them. The version number indicates the latest version tested with the pipeline.</p>

<table><thead>
<tr>
<th align="left">Program</th>
<th align="left">Version</th>
<th align="left">Download Link</th>
</tr>
</thead><tbody>
<tr>
<td align="left">BWA</td>
<td align="left">0.7.12</td>
<td align="left"><a href="http://bio-bwa.sourceforge.net/">http://bio-bwa.sourceforge.net/</a></td>
</tr>
<tr>
<td align="left">bedtools</td>
<td align="left">2.25.0</td>
<td align="left"><a href="https://bedtools.readthedocs.io/en/latest/">https://bedtools.readthedocs.io/en/latest/</a></td>
</tr>
<tr>
<td align="left">Samtools</td>
<td align="left">1.5</td>
<td align="left"><a href="http://www.htslib.org/">http://www.htslib.org/</a></td>
</tr>
<tr>
<td align="left">Picard</td>
<td align="left">2.1.0</td>
<td align="left"><a href="https://broadinstitute.github.io/picard/">https://broadinstitute.github.io/picard/</a></td>
</tr>
<tr>
<td align="left">Vardict (Java)</td>
<td align="left">1.4.6</td>
<td align="left"><a href="https://github.com/AstraZeneca-NGS/VarDictJava">https://github.com/AstraZeneca-NGS/VarDictJava</a></td>
</tr>
<tr>
<td align="left">FastQC</td>
<td align="left">0.11.4</td>
<td align="left"><a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/">https://www.bioinformatics.babraham.ac.uk/projects/fastqc/</a></td>
</tr>
</tbody></table>

<h2>Directory Structure</h2>

<pre><code>Note that only the top output directory needs to be manually created

  .                           # Supplied output directory
   |-2018-11-12-plots         # Contains generated plots used in report
   |---sample-coverage        # Coverage plots generated per-sample
   |-2018-11-12-variant-data  # Final output files, including the PDF report
   |-78                       # Directory for each sample, containing intermediary files
   |---mutect                 # Files produced by MuTect for each sample
   |---vardict                # Files produced by VarDict for each sample
   |-code                     # Bash scripts used to submit jobs to HPC scheduler
   |-log                      # stdout and stderr for each job

</code></pre>

<h2>Stages</h2>

<p>There are four stages to the VariTAS pipeline: alignment, variant calling, annotation, and merging. </p>

<table><thead>
<tr>
<th align="left">Stage</th>
<th align="left">Description</th>
</tr>
</thead><tbody>
<tr>
<td align="left">Alignment</td>
<td align="left">Align FASTQ files to reference genome</td>
</tr>
<tr>
<td align="left">Variant Calling</td>
<td align="left">Run variant callers on aligned BAM files</td>
</tr>
<tr>
<td align="left">Annotation</td>
<td align="left">Annotate variants with ANNOVAR</td>
</tr>
<tr>
<td align="left">Merging</td>
<td align="left">Merge files from all variant callers and produce reports/ plots</td>
</tr>
</tbody></table>

<h3>Alignment</h3>

<p>Alignment consists of two main steps: alignment with bwa, and coverage quality control.</p>

<p>For Illumina sequencing runs, both steps will typically be necessary. For Proton runs, the machine does the alignment against UCSC hg19. While the machine also outputs FASTQ files, realigning these yourself is not recommended as read quality information is lost[<sup>1].</sup> </p>

<p>The main function for running alignment is <code>run.alignment()</code>. It takes a FASTQ specification data frame as input, submits one alignment job per sample, and returns a BAM specification data frame.</p>

<pre><code class="r">library(varitas);

output.directory &lt;- &#39;&#39;;

fastq.specification &lt;- data.frame(
    sample.id = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;), 
    patient.id = c(&#39;X&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Y&#39;), 
    tissue = c(&#39;tumour&#39;, &#39;normal&#39;, &#39;tumour&#39;, &#39;normal&#39;), 
    reads = c(&#39;A_1.fq&#39;, &#39;B_1.fq&#39;, &#39;C_1.fq&#39;, &#39;D_1.fq&#39;),
    mates = c(&#39;A_2.fq&#39;, &#39;B_2.fq&#39;, &#39;C_2.fq&#39;, &#39;D_2.fq&#39;)
    );

print(fastq.specification);
</code></pre>

<pre><code>##   sample.id patient.id tissue  reads  mates
## 1         A          X tumour A_1.fq A_2.fq
## 2         B          X normal B_1.fq B_2.fq
## 3         C          Y tumour C_1.fq C_2.fq
## 4         D          Y normal D_1.fq D_2.fq
</code></pre>

<p>The FASTQ specification must have columns <strong>sample.id</strong> and <strong>reads</strong>. Optionally, it can contain a column <strong>mates</strong> (for paired end reads), and columns <strong>patient.ID</strong> and <strong>tissue</strong>. If provided, the patient ID and tissue information will be used to do matched normal somatic variant calling in later stages of the pipeline. </p>

<p>After creating the FASTQ specification data frame, we are ready to run the alignment step of the pipeline.</p>

<pre><code class="r">matched.bam.specification &lt;- run.alignment(
    fastq.specification = fastq.specification, 
    output.directory = output.directory, 
    paired.end = TRUE,
    quiet = TRUE # only for testing, does not submit jobs to cluster
    );
</code></pre>

<p>The alignment step returns a BAM specification data frame that can be used for the variant calling. When patient ID and tissue information is provided in the input data frame, the output data frame will contain tumour and normal BAM files for each tumour sample. When no patient ID/ tissue information is provided, all samples are assumed to be tumours, and variant calling without matched normal is performed in the subsequent step.</p>

<pre><code class="r">print(matched.bam.specification);
</code></pre>

<pre><code>##   sample.id                   tumour.bam                   normal.bam
## 1         A /A/A.sorted.bam.ontarget.bam /B/B.sorted.bam.ontarget.bam
## 2         C /C/C.sorted.bam.ontarget.bam /D/D.sorted.bam.ontarget.bam
##    job.dependency
## 1 align_A align_B
## 2 align_C align_D
</code></pre>

<h3>Variant Calling</h3>

<p>Variant calling is performed through the <code>run.variant.calling()</code> function. The form of the input BAM specification depends on whether matched normals are available. If no matched normals are available, the only two required columns are <strong>sample.id</strong> and <strong>tumour.bam</strong>. </p>

<pre><code class="r">unmatched.bam.specification &lt;- data.frame(
    sample.id = c(&#39;Z&#39;, &#39;Y&#39;), 
    tumour.bam = c(&#39;Z.bam&#39;, &#39;Y.bam&#39;)
    );

print(unmatched.bam.specification);
</code></pre>

<pre><code>##   sample.id tumour.bam
## 1         Z      Z.bam
## 2         Y      Y.bam
</code></pre>

<p>In addition to the bam specification data frame, <code>run.variant.calling()</code> takes the variant callers as an argument. To run VarDict and MuTect 2 on the previous matched normal example, you can use the following code.</p>

<pre><code class="r">vcf.specification &lt;- run.variant.calling(
    matched.bam.specification, 
    output.directory = output.directory, 
    variant.caller = c(&#39;vardict&#39;, &#39;mutect&#39;),
    quiet = TRUE # only for testing, does not submit jobs to cluster
    );
</code></pre>

<pre><code class="r">print(vcf.specification);
</code></pre>

<pre><code>##           sample.id                              vcf job.dependency  caller
## vardict-A         A /A/vardict/A.passed.ontarget.vcf      vardict_A vardict
## vardict-C         C /C/vardict/C.passed.ontarget.vcf      vardict_C vardict
## mutect-A          A  /A/mutect/A.passed.ontarget.vcf       mutect_A  mutect
## mutect-C          C  /C/mutect/C.passed.ontarget.vcf       mutect_C  mutect
</code></pre>

<p>The VCF specification includes information on the variant caller used to produce the VCF file. This is needed for downstream filtering steps, and used to create unique job names for annotation jobs.</p>

<h4>VarDict</h4>

<p><a href="https://github.com/AstraZeneca-NGS/VarDict">VarDict</a> [@vardict] is a variant caller optimized for deep sequencing. As performance scales linearly with depth, downsampling reads is not necessary, and VarDict has greater sensitivity for detecting variants present at low allele frequencies compared to other callers.</p>

<h4>MuTect</h4>

<p><a href="https://software.broadinstitute.org/cancer/cga/mutect">MuTect</a> [@mutect] is most commonly used for calling variants from whole genome and whole exome sequencing data. It is not optimized for amplicon data, and downsamples to depth 1,000 when it encounters deep sequencing data. When detecting variants in circulating DNA, this downsampling can result in mutations being lost, and running MuTect is not recommended. However, when sequencing solid tumours the variant allele frequencies are higher and there is less concern about losing mutations.  </p>

<h3>Annotation</h3>

<p>Variant file annotation is done with ANNOVAR, and annotated variants are saved to a tab-separated file. The config file specifies the fields to be included in the final tab-separated file. More fields can be added as long as they are included in the ANNOVAR databases.</p>

<pre><code class="r">variant.specification &lt;- run.annotation(
    vcf.specification, 
    output.directory = output.directory, 
    quiet = TRUE # testing only
    );
</code></pre>

<pre><code class="r">print(variant.specification);
</code></pre>

<h3>Merging</h3>

<p>The main function for submitting the post-processing job to the cluster is <code>run.post.processing()</code>. Similar to the alignment, variant calling, and variant annotation stages, this function will submit a cluster job with job dependencies as specified by the variant specification. </p>

<p>However, unlike the other stages, the post processing stage does not rely on any command line tools. If there are no job dependencies, the post-processing stage can be run directly through the <code>post.processing()</code> function. </p>

<pre><code class="r">run.post.processing(
    variant.specification = variant.specification, 
    output.directory = output.directory, 
    quiet = TRUE
    );
</code></pre>

<p>There are three main parts to the post-processing stage:</p>

<ol>
<li><p>Variant merging </p></li>
<li><p>Summary plots and PDF report</p></li>
<li><p>Quality control Excel sheet</p></li>
</ol>

<p>The output is split between two date-stamped subdirectories of the project directory. The <code>variant-data</code> directory contains files that are meant to be sent to collaborators: filtered variants in Excel and text formats, coverage statistics in Excel format, and a PDF report. Additionally, the PNG format plots are saved to the <code>plots</code> directory.</p>

<p>The final page of the PDF report contains details on the pipeline run, including the path to the directory on scratch where the rest of the files can be found.</p>

<pre><code>## VariTAS version 0.7.0
##  Date: 2018-04-26
##  User: username

## Raw/intermediate files can be found in
##  /data/analysis_dir
</code></pre>

<h2>Running the Full Pipeline</h2>

<p>In most cases, all steps in the pipeline can be executed with a single function call. <code>run.varitas.pipeline()</code> is the main function for launching the full pipeline. </p>

<p>By default, this will run all stages from alignment to post-processing. To start the pipeline at a later stage, adjust the <code>start.stage</code> argument of the function. Whatever start stage you provide must match the files provided in the <code>file.details</code> data frame. For example, if starting the pipeline at the variant annotation stage, the <code>file.details</code> data frame should contain paths to VCF files containing the variant calls, and be formatted in a way that passes the <code>verify.variant.specification()</code> check. </p>

<p>Running the <code>run.varitas.pipeline()</code> function will submit jobs for all stages at once, with appropriate job dependencies. To see which jobs that would be submitted, run <code>run.varitas.pipeline()</code> with the argument <code>quiet = TRUE</code>. This will print out all of the Perl calls instead of submitting them as system calls. Each Perl call corresponds to one job submitted to the cluster. </p>

<p>When starting the pipeline at a later stage, earlier jobs are dropped and job dependencies are adjusted accordingly.</p>

<pre><code class="r">vcf.specification$job.dependency &lt;- NULL;

run.varitas.pipeline(
    file.details = vcf.specification,
    output.directory = output.directory,
    start.stage = &#39;annotation&#39;,
    quiet = TRUE
    );
</code></pre>

<p>The merging stage of the pipeline supports email notifications. As merging is the last stage of the pipeline, the email notification can be used to let you know when the pipeline run finishes. </p>

<pre><code class="r">run.varitas.pipeline(
    file.details = vcf.specification,
    output.directory = output.directory,
    start.stage = &#39;annotation&#39;,
    email = &#39;sid@pid.ac.uk&#39;,
    quiet = TRUE
    );
</code></pre>

<h2>Updating Settings {#settings}</h2>

<p>The VariTAS pipeline comes with a set of default options specified in the <code>config.yaml</code> file. These are loaded into R by default, and will enable you to run the pipeline. The settings include both cluster-specific settings that are unlikely to change once they have been set for your HPC system and run-specific settings that are more likely to change. Examples of run-specific settings are the target panel, sequencing platform, and variant filters. </p>

<p>In most cases you will want to make changes to the default settings. There are two ways of doing this.</p>

<ol>
<li><p>Create your own config file, and overwrite all config options with the <code>overwrite.varitas.options()</code> function. </p></li>
<li><p>Update individual options with the <code>set.varitas.options()</code> function.</p></li>
</ol>

<h3>Variant Filters</h3>

<p>Variant filters are specified as part of the settings. All these settings should start with the prefix <code>filters</code> (e.g. be nested under <code>filters</code> in the YAML file), and be further grouped by variant caller. For example, to set a MuTect-specific filter <code>FILTER_NAME</code>, use the command <code>set.varitas.options(filters.mutect.FILTER_NAME = TRUE)</code>. </p>

<p>To specify a filter for all variant callers, list them under <code>default</code> in the config YAML file. These filters are set first and overwritten by any caller-specific filters. For example, the YAML code below would set the <code>remove_exac</code> filter for all variant callers and a <code>min_tumour_depth</code> filter of 10 for all callers except VarDict. The VarDict minimum tumour depth filter is set to 20.</p>

<pre><code>filters:
  default:
    min_tumour_depth: 10
    remove_exac: true
  vardict:
    min_tumour_depth: 20
</code></pre>

<p>The <code>set.varitas.options()</code> function currently does not support default filters. These must be specified through a config YAML file that&#39;s passed to the <code>overwrite.varitas.options()</code> function.</p>

<p>The table below describes all filters currently supported. Variants that do not meet all of these criteria will be filtered out. Note that filters with &ldquo;normal&rdquo; in the name are only applied if the samples are paired tumour/normal.</p>

<table><thead>
<tr>
<th align="left">Name</th>
<th align="left">Value</th>
<th align="left">Description</th>
</tr>
</thead><tbody>
<tr>
<td align="left">min_tumour_variant_reads</td>
<td align="left">numeric</td>
<td align="left">Minimum number of reads supporting a variant</td>
</tr>
<tr>
<td align="left">max_normal_variant_reads</td>
<td align="left">numeric</td>
<td align="left">Maximum number of reads in supporting a variant in normal</td>
</tr>
<tr>
<td align="left">min_tumour_depth</td>
<td align="left">numeric</td>
<td align="left">Minimum depth in tumour</td>
</tr>
<tr>
<td align="left">min_normal_depth</td>
<td align="left">numeric</td>
<td align="left">Minimum depth in normal</td>
</tr>
<tr>
<td align="left">min_tumour_allele_frequency</td>
<td align="left">numeric</td>
<td align="left">Minimum tumour allele frequency</td>
</tr>
<tr>
<td align="left">max_normal_allele_frequency</td>
<td align="left">numeric</td>
<td align="left">Maximum normal allele frequency</td>
</tr>
<tr>
<td align="left">indel_min_tumour_allele_frequency</td>
<td align="left">numeric</td>
<td align="left">Minimum tumour allele frequency for indels</td>
</tr>
<tr>
<td align="left">min_quality</td>
<td align="left">numeric</td>
<td align="left">Minimum base quality</td>
</tr>
<tr>
<td align="left">ct_min_tumour_allele_frequency</td>
<td align="left">numeric</td>
<td align="left">Minimum tumour allele frequency for C&gt;T mutations. Intended as an FFPE filter</td>
</tr>
<tr>
<td align="left">remove_1000_genomes</td>
<td align="left">logical</td>
<td align="left">Flag for removing all variants found in 1,000 genomes[<sup>2]</sup></td>
</tr>
<tr>
<td align="left">remove_exac</td>
<td align="left">logical</td>
<td align="left">Flag for removing variants found at AF&gt;0.01 in the Exome Aggregation Consortium</td>
</tr>
<tr>
<td align="left">remove_germline_status</td>
<td align="left">logical</td>
<td align="left">Flag for removing all variants with a status field set to &ldquo;Germline&rdquo;. Intended to be used with VarDict</td>
</tr>
</tbody></table>

<p>To make it easier to specify filters, the pipeline comes with different sets of default options. These are split into defaults for ctDNA and solid tumours, and can be set by <code>mode: ctdna</code> and <code>mode: tumour</code>, respectively. Any filters specified separately will take precedence over the mode default settings.</p>

<p>For example, the following YAML code will use the ctDNA default settings, but update the <code>min_tumour_variant_reads</code> filter to 20 for all callers.</p>

<pre><code>mode: ctDNA
filters:
  default:
    min_tumour_variant_reads: 20
</code></pre>

<h4>Solid Tumour Mode</h4>

<p>The default settings for the solid tumour mode can be found in the <code>tumour_defaults.yaml</code> file in the package directory.</p>

<pre><code>filters:
  default:
    min_normal_depth: 5
    min_tumour_variant_reads: 5
    min_tumour_allele_frequency: 0.05
    max_normal_allele_frequency: 0.02
    ct_min_tumour_allele_frequency: 0.1
    indel_min_tumour_allele_frequency: 0.1
    remove_1000_genomes: true
    remove_exac: true
  vardict:
    remove_germline_status: true
</code></pre>

<h4>ctDNA Mode</h4>

<p>Defaults for variant calling on ctDNA can be found in the <code>ctdna_defaults.yaml</code> file. Due to low purity, variant allele frequencies in circulating DNA will typically be much lower than those in solid tumour samples. To allow for this, the minimum allele frequency filters are decreased. </p>

<pre><code>filters:
  default:
    min_tumour_variant_reads: 5
    min_tumour_allele_frequency: 0.01
    ct_min_tumour_allele_frequency: 0.05
    indel_min_tumour_allele_frequency: 0.05
    min_normal_depth: 5
    max_normal_allele_frequency: 0
    remove_1000_genomes: true
    remove_exac: true
  pgm:
    indel_min_tumour_allele_frequency: 0.02
  vardict:
    remove_germline_status: true
  isis:
    indel_min_tumour_allele_frequency: 0.02
</code></pre>

<h1>Examples and Use Cases</h1>

<h2>Generic Wrapper Script {#examples}</h2>

<p>Any call to the VariTAS pipeline requires data to be passed in the form of a dataframe, so the easiest way to interact with it is to create a simple wrapper R script. The goals of the wrapper are to collect the relevant input files in a dataframe, change any necessary VariTAS options, and call the relevant pipeline function. </p>

<p>We can start by arranging the FASTQ files:</p>

<pre><code class="r">library(varitas)
output.directory &lt;- &#39;.&#39;

fastq.directory &lt;- &#39;inst/extdata/fastq&#39;
fastq.files &lt;- list.files(
  pattern = &#39;R1.*\\.fastq&#39;, 
  path = fastq.directory, 
  full.names = TRUE
  )
fastq.mate.files &lt;- list.files(
  pattern = &#39;R2.*\\.fastq&#39;, 
  path = fastq.directory, 
  full.names = TRUE
  )

fastq.specification &lt;- data.frame(
  # Extract the sample ID from the filename
  sample.id = gsub(&#39;.*Sample0(\\d\\d).*&#39;, &#39;\\1&#39;, basename(fastq.files)),
  reads = fastq.files,
  mates = fastq.mate.files,
  stringsAsFactors = FALSE
  )

print(fastq.specification)
</code></pre>

<pre><code>##   sample.id                                      reads
## 1        01 inst/extdata/fastq/2018_Sample001_R1.fastq
## 2        02 inst/extdata/fastq/2018_Sample002_R1.fastq
## 3        03 inst/extdata/fastq/2018_Sample003_R1.fastq
## 4        04 inst/extdata/fastq/2018_Sample004_R1.fastq
##                                        mates
## 1 inst/extdata/fastq/2018_Sample001_R2.fastq
## 2 inst/extdata/fastq/2018_Sample002_R2.fastq
## 3 inst/extdata/fastq/2018_Sample003_R2.fastq
## 4 inst/extdata/fastq/2018_Sample004_R2.fastq
</code></pre>

<p>Often, you will need to change settings in the VariTAS config file. As shown in the Introduction, this can be done in one of two ways. The first is to use <code>set.varitas.options()</code> within your wrapper script like so:</p>

<pre><code class="r">set.varitas.options(filters.vardict.min_tumour_depth = 10)
</code></pre>

<p>This is suitable for smaller changes, but it is usually more convenient to have a copy of the VariTAS config file for each project or run of the pipeline. This way, all of the settings that are unlikely to change can be easily set and other users will be able to clearly see the config options you used.</p>

<pre><code class="r">config &lt;- &#39;inst/extdata/varitas_config.yaml&#39;
overwrite.varitas.options(config)
</code></pre>

<p>Once the above steps are completed, you are ready to call the main function of the pipeline. </p>

<pre><code class="r">run.varitas.pipeline(
    file.details = fastq.specification,
    output.directory = output.directory,
    variant.callers = c(&#39;mutect&#39;, &#39;vardict&#39;),
    quiet = FALSE,
    run.name = &#39;EXAMPLE&#39;,
    email = &#39;sid@pid.ac.uk&#39;
    )
</code></pre>

<p>And those are all the necessary steps to run the pipeline. It will notify you by email when it is finished if you provide an address. On the first attempt, it is advisable to set the <code>quiet</code> parameter to <code>TRUE</code>, which prevents any of the tasks from running. This way, any potential problems can be fixed before a large number of jobs are created.</p>

<p>A full wrapper script template is provided below for completeness and ease of copying-and-pasting.</p>

<pre><code class="r">###############################################################################
## VariTAS Wrapper Script
##
###############################################################################
## Author:
## Adam Mills
###############################################################################
## Libraries:
library(varitas)
###############################################################################
## Main

output.directory &lt;- &#39;.&#39;

fastq.directory &lt;- &#39;inst/extdata/fastq&#39;
fastq.files &lt;- list.files(
  pattern = &#39;R1.*\\.fastq&#39;, 
  path = fastq.directory, 
  full.names = TRUE
  )
fastq.mate.files &lt;- list.files(
  pattern = &#39;R2.*\\.fastq&#39;, 
  path = fastq.directory, 
  full.names = TRUE
  )

fastq.specification &lt;- data.frame(
  sample.id = gsub(&#39;.*Sample0(\\d\\d).*&#39;, &#39;\\1&#39;, basename(fastq.files)),
  reads = fastq.files,
  mates = fastq.mate.files,
  stringsAsFactors = FALSE
  )

config &lt;- &#39;inst/extdata/varitas_config.yaml&#39;
overwrite.varitas.options(config)

run.varitas.pipeline(
  file.details = fastq.specification,
  output.directory = output.directory,
  variant.callers = c(&#39;mutect&#39;, &#39;vardict&#39;),
  quiet = FALSE,
  run.name = &#39;EXAMPLE&#39;,
  email = &#39;sid@pid.ac.uk&#39;
  )
</code></pre>

<h2>Variant Calling with Matched Normal</h2>

<p>Data from normal tissue can be used for matched somatic variant calling in the pipeline. When creating your FASTQ specification dataframe, include the columns <code>patient.id</code> and <code>tissue</code> and the pipeline will submit matched normal data to the variant callers. </p>

<pre><code class="r">fastq.specification &lt;- data.frame(
  sample.id = gsub(&#39;.*Sample0(\\d\\d).*&#39;, &#39;\\1&#39;, basename(fastq.files)),
  patient.id = c(&#39;X&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Y&#39;),
  tissue = c(&#39;tumour&#39;, &#39;normal&#39;, &#39;tumour&#39;, &#39;normal&#39;),
  reads = fastq.files,
  mates = fastq.mate.files,
  stringsAsFactors = FALSE
  )

print(fastq.specification)
</code></pre>

<pre><code>##   sample.id patient.id tissue                                      reads
## 1        01          X tumour inst/extdata/fastq/2018_Sample001_R1.fastq
## 2        02          X normal inst/extdata/fastq/2018_Sample002_R1.fastq
## 3        03          Y tumour inst/extdata/fastq/2018_Sample003_R1.fastq
## 4        04          Y normal inst/extdata/fastq/2018_Sample004_R1.fastq
##                                        mates
## 1 inst/extdata/fastq/2018_Sample001_R2.fastq
## 2 inst/extdata/fastq/2018_Sample002_R2.fastq
## 3 inst/extdata/fastq/2018_Sample003_R2.fastq
## 4 inst/extdata/fastq/2018_Sample004_R2.fastq
</code></pre>

<h2>Ion PGM Data</h2>

<p>Data produced by an Ion PGM system can also be processed by this pipeline using a different function. If you&#39;d like to incorporate the variants called by the machine in the pipeline, simply pass both the BAM files and the VCF files into <code>run.varitas.pipeline.hybrid()</code>. Data from Ion Proton systems can be used in the same way by setting the <code>proton</code> parameter to <code>TRUE</code>.</p>

<pre><code class="r">bam.directory &lt;- &#39;inst/extdata/bam&#39;
bam.files &lt;- list.files(
  pattern = &#39;Sample.*\\.bam&#39;, 
  path = bam.directory, 
  full.names = TRUE
  )
vcf.directory &lt;- &#39;inst/extdata/vcf&#39;
vcf.files &lt;- list.files(
  pattern = &#39;Sample.*\\.vcf&#39;, 
  path = vcf.directory, 
  full.names = TRUE
  )

bam.specification &lt;- data.frame(
  sample.id = gsub(&#39;^Sample_(\\d+).*&#39;, &#39;\\1&#39;, basename(bam.files)),
  tumour.bam = bam.files,
  stringsAsFactors = FALSE
  )
vcf.specification &lt;- data.frame(
  sample.id = gsub(&#39;^Sample_(\\d+).*&#39;, &#39;\\1&#39;, basename(vcf.files)),
  vcf = vcf.files,
  caller = rep(&#39;pgm&#39;, length(vcf.files)),
  stringsAsFactors = FALSE
  )
print(bam.specification)
</code></pre>

<pre><code>##   sample.id                    tumour.bam
## 1         1 inst/extdata/bam/Sample_1.bam
## 2         2 inst/extdata/bam/Sample_2.bam
</code></pre>

<pre><code class="r">print(vcf.specification)
</code></pre>

<pre><code>##   sample.id                           vcf caller
## 1         1 inst/extdata/vcf/Sample_1.vcf    pgm
## 2         2 inst/extdata/vcf/Sample_2.vcf    pgm
</code></pre>

<pre><code class="r">run.varitas.pipeline.hybrid(
    bam.specification = bam.specification,
    vcf.specification = vcf.specification,
    output.directory = &#39;inst/extdata/output/&#39;,
    proton = TRUE,
    run.name = &#39;EXAMPLE&#39;,
    quiet = FALSE,
    email = &#39;sid@pid.ac.uk&#39;
    );
</code></pre>

<p>In this version of the pipeline, the alignment stage is skipped and the Ion PGM variant data will be incorporated into the final reports. </p>

<h2>MiniSeq Data</h2>

<p>To enable users to quickly build file specifications for MiniSeq runs, the VariTAS pipeline has a function <code>prepare.miniseq.specifications()</code>. When passed a MiniSeq sample sheet and the path to a MiniSeq directory, the function will parse through the directory and look for FASTQ/ BAM/ VCF files for each of the samples. By default the <code>Sample_ID</code> column of the MiniSeq sample sheet, up to the first dash, is taken as the sample ID.</p>

<p><code>prepare.miniseq.specifications()</code> returns a list with elements corresponding to the different file types that have been found. For example, if VCF files were present in the VCF directory, a VCF specification will be named as <code>vcf</code> in the result. Note that you will have to add a column <code>caller</code> to the VCF specification before it can be used in the pipeline.</p>

<pre><code class="r">miniseq.sheet &lt;- &#39;inst/extdata/miniseq/Example_template.csv&#39;
miniseq.directory &lt;- &#39;inst/extdata/miniseq&#39;

miniseq.info &lt;- prepare.miniseq.specifications(miniseq.sheet, miniseq.directory)
</code></pre>

<pre><code>## Found directories fastq vcf
</code></pre>

<pre><code class="r">fastq.specification &lt;- miniseq.info[[ 1 ]]
vcf.specification &lt;- miniseq.info[[ 2 ]]
vcf.specification[&#39;caller&#39;] &lt;- rep(&#39;miniseq&#39;, nrow(vcf.specification))

print(fastq.specification)
</code></pre>

<pre><code>##     sample.id                                                   reads
## 001       001 inst/extdata/miniseq/fastq/001_S1_L001_R1_example.fastq
## 002       002 inst/extdata/miniseq/fastq/002_S1_L001_R1_example.fastq
##                                                       mates
## 001 inst/extdata/miniseq/fastq/001_S1_L001_R2_example.fastq
## 002 inst/extdata/miniseq/fastq/002_S1_L001_R2_example.fastq
</code></pre>

<pre><code class="r">print(vcf.specification)
</code></pre>

<pre><code>##     sample.id                                          vcf  caller
## 001       001 inst/extdata/miniseq/isis/001_S1_example.vcf miniseq
## 002       002 inst/extdata/miniseq/isis/002_S1_example.vcf miniseq
</code></pre>

<h3>Incorporating MiniSeq Variant Calls</h3>

<p>The dataframes generated by the <code>prepare.miniseq.specifications</code> function can be fed into the standard pipeline, or they can be used in the hybrid pipeline. In the latter case, you are able to pass the VCF files much like the Ion PGM scenario in Example 2. By doing so, the pipeline will include the MiniSeq variant calls in the final output.</p>

<pre><code class="r">run.varitas.pipeline.hybrid(
    fastq.specification = fastq.specification,
    vcf.specification = vcf.specification,
    output.directory = &#39;inst/extdata/output/&#39;,
    run.name = &#39;EXAMPLE&#39;,
    quiet = FALSE,
    email = &#39;sid@pid.ac.uk&#39;
    )
</code></pre>

<h2>References</h2>

<p>[<sup>1]:</sup> Ion machines use SFF files, which are then converted back to FASTQ. This results in the loss of information on read quality. Another problem with aligning the Ion Torrent FASTQs is the distinct homopolymer error profiles of ion semiconductor sequencing. This is accounted for with the machine aligner, but not by BWA.
[<sup>2]:</sup> Data from phase 3 of the 1,000 genomes project is obtained through ANNOVAR.</p>

</body>

</html>
